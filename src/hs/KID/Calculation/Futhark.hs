{-| Dispatch to Futhark for simulations/calculations -}

{-# LANGUAGE RecordWildCards #-}

module KID.Calculation.Futhark
    where

import qualified Data.Array.Storable   as S
import qualified Data.Array            as A
import           Data.Int
import           Data.Time.Calendar
import           Foreign.Marshal.Alloc
import           Foreign.Marshal.Array
import           Foreign.Ptr
import           Foreign.Storable
import           Foreign               as F

import           KID.Domain

data Futhark_Context_Config
data Futhark_Context
data Futhark_f64_1d
data Futhark_f64_2d

foreign import ccall "futhark_context_config_new"
  futhark_context_config_new :: IO (Ptr Futhark_Context_Config)

foreign import ccall "futhark_context_config_free"
  futhark_context_config_free :: Ptr Futhark_Context_Config -> IO ()

foreign import ccall "futhark_context_new"
  futhark_context_new :: Ptr Futhark_Context_Config -> IO (Ptr Futhark_Context)

foreign import ccall "futhark_context_free"
  futhark_context_free :: Ptr Futhark_Context -> IO ()

foreign import ccall "futhark_new_f64_1d"
  futhark_new_f64_1d :: Ptr Futhark_Context -> Ptr Double -> Int64 -> IO (Ptr Futhark_f64_1d)

foreign import ccall "futhark_new_f64_2d"
  futhark_new_f64_2d :: Ptr Futhark_Context -> Ptr Double -> Int64 -> Int64 -> IO (Ptr Futhark_f64_2d)

foreign import ccall unsafe "futhark_values_f64_2d"
  values_f64_2d :: Ptr Futhark_Context -> Ptr Futhark_f64_2d -> Ptr Double -> IO Int

--Entry points (generated by futhask)
foreign import ccall unsafe "futhark_entry_sample_contract_1"
  entry_sample_contract_1
    :: Ptr Futhark_Context
    -> Ptr Double
    -> Ptr Double
    -> Ptr Int64
    -> Ptr (Ptr Futhark_f64_2d)
    -> Int64
    -> Ptr Futhark_f64_1d
    -> Ptr Futhark_f64_2d
    -> IO Int

foreign import ccall unsafe "futhark_entry_sample_contract_2"
  entry_sample_contract_2
    :: Ptr Futhark_Context
    -> Ptr Double
    -> Ptr Double
    -> Ptr Int64
    -> Ptr (Ptr Futhark_f64_2d)
    -> Int64
    -> Ptr Futhark_f64_1d
    -> Ptr Futhark_f64_2d
    -> IO Int

newtype Ptr_Futhark = Ptr_Futhark {
  ptr_fut_ctx_cfg :: Ptr Futhark_Context_Config
  -- TODO:
  --    * seed
  --    * futhark log file
}

ptr_futhark_new :: IO Ptr_Futhark
ptr_futhark_new = Ptr_Futhark <$> futhark_context_config_new

futhark_entry_point SampleContract1     = entry_sample_contract_1
futhark_entry_point SampleContract2{..} = entry_sample_contract_2

futhark_contract :: ProductType
                 -> Ptr_Futhark
                 -> Integer                                                            -- ^ rhp (recommended holding period) in days
                 -> Contract                                                           -- ^ contract
                 -> S.StorableArray (Int,Day) Double                                   -- ^ historical data
                 -> IO (Double, Double, Int, Scenario, Maybe Scenario, Maybe Scenario) -- ^ VaR, VEV, MRM and scenarios

futhark_contract p x t c@Contract{..} a = let cfg = ptr_fut_ctx_cfg x in do
  ctx <- futhark_context_new cfg
  out <- S.newArray ((1,1),(3,4)) nan
  withArray (weights c) $ \ptr0 -> do
    w <- futhark_new_f64_1d ctx ptr0 (fromIntegral $ length underlyings)
    S.withStorableArray a $ \ptr1 -> do
      (m,n) <- dims a
      arr   <- futhark_new_f64_2d ctx ptr1 m n
      F.malloc >>= \var'
        -> F.malloc >>= \vev'
        -> F.malloc >>= \mrm'
        -> F.malloc >>= \sce'
        -> do futhark_entry_point product_type ctx var' vev' mrm' sce' (fromIntegral t) w arr
              S.withStorableArray out $ \ptr2 -> do
                peekFree var' >>= \var
                  -> peekFree vev' >>= \vev
                  -> peekFree mrm' >>= \mrm
                  -> peekFree sce' >>= \sce
                  -> do values_f64_2d ctx sce ptr2
                        v1 <- S.readArray out (1,1)
                        v2 <- S.readArray out (1,2)
                        v3 <- S.readArray out (1,3)
                        v4 <- S.readArray out (1,4)
                        h1 <- S.readArray out (2,1)
                        h2 <- S.readArray out (2,2)
                        h3 <- S.readArray out (2,3)
                        h4 <- S.readArray out (2,4)
                        o1 <- S.readArray out (2,1)
                        o2 <- S.readArray out (2,2)
                        o3 <- S.readArray out (2,3)
                        o4 <- S.readArray out (2,4)
                        let i1 = if isNaN h1 then Nothing else Just (Scenario h1 h2 h3 h4)
                        let i2 = if isNaN o1 then Nothing else Just (Scenario o1 o2 o3 o4)
                        return (var, vev, fromIntegral mrm, Scenario v1 v2 v3 v4, i1, i2)
  where
    nan :: Double
    nan = 0/0

    weights :: Contract -> [Double]
    weights Contract{..} = map weight underlyings

-- Helpers

peekFree :: Storable b => Ptr b -> IO b
peekFree p = peek p >>= \v -> free p >> return v

dims :: S.StorableArray (Int,Day) Double -> IO (Int64, Int64)
dims a = S.getBounds a >>= \((v1,d1),(v2,d2)) -> return (fromIntegral $ v2-v1+1, fromIntegral $ diffDays d2 d1 + 1)
